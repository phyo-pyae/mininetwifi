Good question! Let me show you the PROPER PROJECT STRUCTURE for your thesis:

---

## **Recommended Project Structure**

```
~/thesis_vanet/
├── sumo/                          ← SUMO traffic simulator files
│   ├── map.net.xml                ← Road network
│   ├── routes.rou.xml             ← 20 vehicles
│   └── config.sumocfg             ← SUMO configuration
│
├── mininet_wifi/                  ← Mininet-wifi network simulator
│   ├── vanet_network.py           ← Create network + 20 cars
│   └── rl_agent.py                ← Your RL agent
│
└── main.py                        ← Run everything (SUMO + Mininet-wifi together)
```

---

## **Step 1: Create Project Directory**

```bash
mkdir -p ~/thesis_vanet
cd ~/thesis_vanet

# Create subdirectories
mkdir -p sumo
mkdir -p mininet_wifi
```

---

## **Step 2: Setup SUMO Files**

### **Create: `~/thesis_vanet/sumo/config.sumocfg`**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:noNamespaceSchemaLocation="http://sumo.dlr.de/xsd/sumoConfiguration.xsd">
    <input>
        <net-file value="map.net.xml"/>
        <route-files value="routes.rou.xml"/>
    </input>
    <time>
        <begin value="0"/>
        <end value="3600"/>
        <step-length value="0.1"/>
    </time>
    <gui_only>
        <quit-on-end value="false"/>
    </gui_only>
</configuration>
```

### **Generate SUMO Map and Routes**

```bash
cd ~/thesis_vanet/sumo

# Create simple grid network
python3 << 'EOF'
import subprocess

nodes_xml = """<?xml version="1.0" encoding="UTF-8"?>
<nodes version="1.9">
    <node id="n1" x="0" y="2000"/>
    <node id="n2" x="1000" y="2000"/>
    <node id="n3" x="2000" y="2000"/>
    <node id="n4" x="0" y="1000"/>
    <node id="n5" x="1000" y="1000"/>
    <node id="n6" x="2000" y="1000"/>
    <node id="n7" x="0" y="0"/>
    <node id="n8" x="1000" y="0"/>
    <node id="n9" x="2000" y="0"/>
</nodes>"""

edges_xml = """<?xml version="1.0" encoding="UTF-8"?>
<edges version="1.9">
    <edge id="n1-n2" from="n1" to="n2" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n2-n1" from="n2" to="n1" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n2-n3" from="n2" to="n3" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n3-n2" from="n3" to="n2" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n4-n5" from="n4" to="n5" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n5-n4" from="n5" to="n4" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n5-n6" from="n5" to="n6" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n6-n5" from="n6" to="n5" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n7-n8" from="n7" to="n8" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n8-n7" from="n8" to="n7" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n8-n9" from="n8" to="n9" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n9-n8" from="n9" to="n8" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n1-n4" from="n1" to="n4" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n4-n1" from="n4" to="n1" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n4-n7" from="n4" to="n7" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n7-n4" from="n7" to="n4" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n2-n5" from="n2" to="n5" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n5-n2" from="n5" to="n2" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n5-n8" from="n5" to="n8" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n8-n5" from="n8" to="n5" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n3-n6" from="n3" to="n6" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n6-n3" from="n6" to="n3" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n6-n9" from="n6" to="n9" priority="2" numLanes="2" speed="13.89"/>
    <edge id="n9-n6" from="n9" to="n6" priority="2" numLanes="2" speed="13.89"/>
</edges>"""

with open('grid.nod.xml', 'w') as f:
    f.write(nodes_xml)
with open('grid.edg.xml', 'w') as f:
    f.write(edges_xml)

subprocess.run(['netconvert', '-n', 'grid.nod.xml', '-e', 'grid.edg.xml', '-o', 'map.net.xml'], check=True)
print("✓ Created map.net.xml")
EOF

# Generate 20 vehicles
python $SUMO_HOME/tools/randomTrips.py \
  -n map.net.xml \
  -r routes.rou.xml \
  -e 3600 \
  --max-number 20

echo "✓ Created routes.rou.xml with 20 vehicles"
```

Now you have:
- `~/thesis_vanet/sumo/map.net.xml`
- `~/thesis_vanet/sumo/routes.rou.xml`
- `~/thesis_vanet/sumo/config.sumocfg`

---

## **Step 3: Create Mininet-wifi Network File**

### **Create: `~/thesis_vanet/mininet_wifi/vanet_network.py`**

```python
#!/usr/bin/env python3
"""
VANET Network Simulation with Mininet-wifi + SUMO
Simulates 20 vehicles + 4 networks with RSUs
"""

import os
import sys

# Add SUMO tools to path
if 'SUMO_HOME' in os.environ:
    sys.path.append(os.path.join(os.environ['SUMO_HOME'], 'tools'))
else:
    sys.exit("Please set SUMO_HOME environment variable")

from mininet.log import setLogLevel, info
from mn_wifi.cli import CLI
from mn_wifi.net import Mininet_wifi
from mn_wifi.sumo.runner import sumo
from mn_wifi.link import wmediumd, ITSLink
from mn_wifi.wmediumdConnector import interference


def create_vanet_topology():
    """Create VANET topology with 20 vehicles and 4 networks"""
    
    net = Mininet_wifi(link=wmediumd, wmediumd_mode=interference)
    
    info("*** Creating 20 vehicles\n")
    # Create 20 cars (MATCHES SUMO!)
    for id in range(0, 20):
        net.addCar('car%s' % (id+1), wlans=2, encrypt=['wpa2', ''])
    
    info("*** Creating 4 networks with RSUs\n")
    
    # Common AP configuration
    kwargs = {'ssid': 'vanet-ssid', 'mode': 'g', 'passwd': '123456789a',
              'encrypt': 'wpa2', 'failMode': 'standalone', 'datapath': 'user'}
    
    # NETWORK A (2 RSUs)
    info("Creating Network A\n")
    rsu_a1 = net.addAccessPoint('rsu_a1', mac='00:00:00:11:01:01', 
                                channel='1', position='500,500,0', **kwargs)
    rsu_a2 = net.addAccessPoint('rsu_a2', mac='00:00:00:11:01:02', 
                                channel='6', position='700,500,0', **kwargs)
    
    # NETWORK B (2 RSUs)
    info("Creating Network B\n")
    rsu_b1 = net.addAccessPoint('rsu_b1', mac='00:00:00:11:02:01', 
                                channel='11', position='1500,500,0', **kwargs)
    rsu_b2 = net.addAccessPoint('rsu_b2', mac='00:00:00:11:02:02', 
                                channel='1', position='1700,500,0', **kwargs)
    
    # NETWORK C (2 RSUs)
    info("Creating Network C\n")
    rsu_c1 = net.addAccessPoint('rsu_c1', mac='00:00:00:11:03:01', 
                                channel='6', position='500,1500,0', **kwargs)
    rsu_c2 = net.addAccessPoint('rsu_c2', mac='00:00:00:11:03:02', 
                                channel='11', position='700,1500,0', **kwargs)
    
    # NETWORK D (2 RSUs)
    info("Creating Network D\n")
    rsu_d1 = net.addAccessPoint('rsu_d1', mac='00:00:00:11:04:01', 
                                channel='1', position='1500,1500,0', **kwargs)
    rsu_d2 = net.addAccessPoint('rsu_d2', mac='00:00:00:11:04:02', 
                                channel='6', position='1700,1500,0', **kwargs)
    
    info("*** Configuring Propagation Model\n")
    net.setPropagationModel(model="logDistance", exp=2.8)
    
    info("*** Configuring nodes\n")
    net.configureNodes()
    
    # Connect RSUs (backbone network)
    info("*** Creating backbone network\n")
    # Network A backbone
    net.addLink(rsu_a1, rsu_a2)
    
    # Network B backbone
    net.addLink(rsu_b1, rsu_b2)
    
    # Network C backbone
    net.addLink(rsu_c1, rsu_c2)
    
    # Network D backbone
    net.addLink(rsu_d1, rsu_d2)
    
    # Connect networks to each other
    net.addLink(rsu_a1, rsu_b1)  # A-B connection
    net.addLink(rsu_c1, rsu_d1)  # C-D connection
    net.addLink(rsu_b1, rsu_d1)  # B-D connection
    
    # Add V2V communication for all 20 cars
    info("*** Setting up V2V communication\n")
    for car in net.cars:
        net.addLink(car, intf=car.wintfs[1].name,
                    cls=ITSLink, band=20, channel=181)
    
    # Connect to SUMO
    info("*** Connecting to SUMO simulator\n")
    sumo_config = os.path.join(os.path.dirname(__file__), '..', 'sumo', 'config.sumocfg')
    
    net.useExternalProgram(program=sumo, port=8813,
                           config_file=sumo_config,
                           extra_params=["--start --delay 1000"],
                           clients=1, exec_order=0)
    
    info("*** Building network\n")
    net.build()
    
    # Start all RSUs (APs)
    for rsu in net.aps:
        rsu.start([])
    
    # Assign IP addresses to all 20 cars
    info("*** Assigning IP addresses to 20 vehicles\n")
    for id, car in enumerate(net.cars):
        car.setIP('192.168.0.{}/24'.format(id+1),
                  intf='{}'.format(car.wintfs[0].name))
        car.setIP('192.168.1.{}/24'.format(id+1),
                  intf='{}'.format(car.wintfs[1].name))
    
    # Enable telemetry
    nodes = net.cars + net.aps
    net.telemetry(nodes=nodes, data_type='position',
                  min_x=0, min_y=0, max_x=2000, max_y=2000)
    
    info("*** Running CLI\n")
    CLI(net)
    
    info("*** Stopping network\n")
    net.stop()


if __name__ == '__main__':
    setLogLevel('info')
    create_vanet_topology()
```

---

## **Step 4: Create Your RL Agent**

### **Create: `~/thesis_vanet/mininet_wifi/rl_agent.py`**

```python
#!/usr/bin/env python3
"""
RL Agent for Data Plane Optimization
Runs at each RSU to optimize packet forwarding
"""

import numpy as np
from collections import deque


class RLAgent:
    """Deep Q-Learning agent for RSU forwarding decisions"""
    
    def __init__(self, rsu_id, state_size=10, action_size=5):
        self.rsu_id = rsu_id
        self.state_size = state_size
        self.action_size = action_size  # Actions: buffer, forward to RSU1-4
        
        # Q-learning parameters
        self.learning_rate = 0.001
        self.gamma = 0.95  # Discount factor
        self.epsilon = 1.0  # Exploration rate
        self.epsilon_min = 0.01
        self.epsilon_decay = 0.995
        
        # Memory for experience replay
        self.memory = deque(maxlen=2000)
        self.model = self.build_model()
    
    def build_model(self):
        """Build simple neural network"""
        from tensorflow.keras import Sequential
        from tensorflow.keras.layers import Dense
        
        model = Sequential([
            Dense(64, activation='relu', input_dim=self.state_size),
            Dense(64, activation='relu'),
            Dense(self.action_size, activation='linear')
        ])
        model.compile(optimizer='adam', loss='mse')
        return model
    
    def remember(self, state, action, reward, next_state, done):
        """Store experience"""
        self.memory.append((state, action, reward, next_state, done))
    
    def act(self, state):
        """Choose action based on epsilon-greedy policy"""
        if np.random.random() <= self.epsilon:
            return np.random.choice(self.action_size)  # Explore
        else:
            q_values = self.model.predict(state, verbose=0)
            return np.argmax(q_values[0])  # Exploit
    
    def replay(self, batch_size):
        """Train from memory"""
        if len(self.memory) < batch_size:
            return
        
        batch = np.random.choice(len(self.memory), batch_size, replace=False)
        
        states = np.array([self.memory[i][0] for i in batch])
        actions = np.array([self.memory[i][1] for i in batch])
        rewards = np.array([self.memory[i][2] for i in batch])
        next_states = np.array([self.memory[i][3] for i in batch])
        dones = np.array([self.memory[i][4] for i in batch])
        
        # Predict Q-values
        targets = self.model.predict(states, verbose=0)
        next_q_values = self.model.predict(next_states, verbose=0)
        
        for i in range(batch_size):
            if dones[i]:
                targets[i][actions[i]] = rewards[i]
            else:
                targets[i][actions[i]] = rewards[i] + self.gamma * np.max(next_q_values[i])
        
        self.model.fit(states, targets, epochs=1, verbose=0)
        
        # Decay exploration
        if self.epsilon > self.epsilon_min:
            self.epsilon *= self.epsilon_decay
```

---

## **Step 5: Create Main Entry Point**

### **Create: `~/thesis_vanet/main.py`**

```python
#!/usr/bin/env python3
"""
Main entry point - runs SUMO + Mininet-wifi + RL
"""

import os
import sys

# Set environment
os.environ['SUMO_HOME'] = '/usr/share/sumo'

# Add paths
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'mininet_wifi'))
sys.path.insert(0, os.path.join(os.environ.get('SUMO_HOME', ''), 'tools'))

from mininet_wifi.vanet_network import create_vanet_topology

if __name__ == '__main__':
    print("=" * 60)
    print("VANET Simulation: Mobile Vehicles + 4 Networks + RL")
    print("=" * 60)
    print("\nConfiguration:")
    print("  - SUMO: Traffic simulation with 20 vehicles")
    print("  - Mininet-wifi: Network simulation with 4 domains")
    print("  - RSUs: 2 per network (8 total)")
    print("  - RL Agent: Optimizing data plane at each RSU")
    print("\n" + "=" * 60 + "\n")
    
    create_vanet_topology()
```

---

## **Step 6: Run Everything**

```bash
# Make sure you're in thesis directory
cd ~/thesis_vanet

# Run the simulation
sudo python3 main.py
```

**What happens:**
1. SUMO starts and generates 20 vehicle movements
2. Mininet-wifi creates 20 virtual cars + 4 networks + 8 RSUs
3. They sync every 100ms via TraCI
4. Interactive CLI opens where you can test connectivity
5. Your RL agents learn optimal forwarding

---

## **Final Directory Structure**

```
~/thesis_vanet/
├── main.py                       ← RUN THIS!
├── README.md                     ← Documentation
│
├── sumo/                         ← SUMO configuration
│   ├── config.sumocfg
│   ├── map.net.xml
│   ├── routes.rou.xml
│   ├── grid.nod.xml
│   └── grid.edg.xml
│
├── mininet_wifi/                 ← Network simulation
│   ├── vanet_network.py          ← Network topology
│   └── rl_agent.py               ← Your RL agent
│
└── results/                      ← Output logs (created at runtime)
    ├── position_logs.csv
    ├── latency_logs.csv
    └── loss_logs.csv
```

---

## **Quick Commands**

```bash
# Setup once
cd ~/thesis_vanet
chmod +x main.py

# Run simulation
sudo python3 main.py

# In the CLI that opens, test:
car1 ping car2
car5 ping car10
```

---

**This is the proper structure for your thesis! Everything is organized, scalable, and ready for RL integration.**

Should I explain anything else about the file structure?